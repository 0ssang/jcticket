## 예매 팝업창 - 설계 순서와 목적 (역순으로 요구사항 도출해볼것)
#### _step1. 일정선택  --> step2. 좌석선택 --> step3. 쿠폰선택 --> step4. 결제방법_

- - - 
- - -

### 1. mapper - sql
       Spring + MyBatis에서 sql 쿼리의 결과와 java 객체가 매핑되는 과정:
       - 기본생성자 NoArgs만 존재하는 경우 null로 매핑됨
       - 기본생성자 NoArgs와 컬럼별칭 Alias가 존재하는 경우 매핑이 정상적으로 이루어짐
       - 모든생성자 AllArgs가 존재하면 Alias기 앖더라도 정상적으로 매핑됨
           * 단, 객체의 필드와 컬럼의 데이터 순서가 일치해야 함
       - 일부 필드에 대한 생성자만 존재할 경우, 해당 필드에 대해서만 매핑됨
       결론 >>> @AllArgs 가 존재하거나 @NoArgs+Alias 조건이 되면 생성자의 개수와 상관없이 정상적으로 매핑됨

#### @AllArgs를 사용할 때 단점 & @NoArgs+Alias를 권장하는 이유
  * 조회 결과값이 어떤 필드에 매핑되어 있는지 하나하나 비교하지 않으면 파악이 힘듦
  * 추후 컬럼이나 코드의 변경 시 @AllArgs는 컬럼 순서를 신경 써야 하므로 유지 보수 면에서 비용이 더 발생할 수 있음
  * alias를 통해 객체의 필드와 컬럼의 순서가 일치하지 않더라도 어떠한 필드가 매핑되는지 바로 파악할 수 있음
#### step1. 일정선택
- 사용 테이블 : showing(회차), play(공연), stage(공연장)
#### step2. 좌석선택
- 사용 테이블 : stage, seat, show_seat, seat_class
- - - 
### 2. Dao / DaoImpl
     DB의 data에 접근하기 위한 객체   
     어플리케이션에서 사용할 DB로직을 객체 하나에 메서드로 구현함
     DB에 대한 단일 접근성 및 모듈화가 중요함
#### step1. 일정선택
* Service 즉 비즈니스 로직이 포함되지 않고 DB에 접근하여 데이터만 가져오자....
* 어떠한 것들이 있을끼? 기적으로 --> Service에서 이용할 수 있는 CRUD 기능이 존재해야 한다.
* CREATE
     + 일정 선택 로직에서는 필요가 없다. 그러나 Test 코드 작성을 위해 형식적으로 만들자
     + insert 쿼리로 회차 DTO를 사용해 DB에 저장한다.
* READ
    + 공연아이디별 회차테이블의 리스트를 List<ShowingDto> 형식으로 가져온다.
    + 공연아이디별 공연명, 공연장명을 HashMap<>으로 가져온다.
    + 공연아이디별 공연일정 리스트를 받아온다.
    + 공연아이디, 공연일정별로, 회차시퀀스, 회차정보를 리스트를 받아온다.
    + 회차시퀀스에 따른 좌석정보를 회차-좌석 테이블에서 가져온다.
    + 공연아이디별 회차 수 카운팅.
* UPDATE
    + 일정 선택에서는 구현하지 않는다.
* DELETE
    + 마찬가지로 일정 선택 팝업창에서 삭제 쿼리는 필요하지 않지만 Test코드 작성을 위해 만들자.
    + delete 쿼리로 회차 테이블의 데이터를 모두 삭제한다.
    + 공연아이디 별 로우를 삭제한다
    + 회차 시퀀스별 로우를 삭제한다.
#### step2. 좌석선택
* CREATE
  + Test 코드 작성을 위해 만들자
  + 회차-좌석 테이블의 DTO를 이용하여 insert
  + 좌석 테이블의 DTO를 이용하여 insert
* READ
  + 회차시퀀스로 좌석행번호, 좌석열번호 , 좌석상태 리스트 조회(count == 공연좌석수)
    - 좌석상태가 'N'인 좌석(행+열)은 비활성화한다.
  + 회차시퀀스로 회차좌석가격 조회
  + (추가: 잔여석 조회) 좌석상태가 N인 좌석의 개수를 카운트한다.
* UPDATE
  + 선택된 좌석아이디의 리스트를 받아 좌석상태를 'Y'로 수정해야 하지만 동시예약 문제 등을 고려하여 결제 완료 시 update쿼리를 날린다.
  
* DELETE

#### step3. 쿠폰선택
* CREATE
  + 지수님 코드 참고
* READ
  + 유저 아이디로 유저-쿠폰 테이블의 유저-쿠폰아이디, 쿠폰아이디 리스트 조회
  + 쿠폰아이디로 쿠폰 테이블에서 쿠폰명, 쿠폰할인가격, 쿠폰사용조건, 쿠폰사용가능시작일, 쿠폰사용가능종료일 조회
* UPDATE
* DELETE
- - -
### 3. Service / ServiceImpl
        사용자의 요청(request)에 대해 어떤 처리를 할지 결정하는 파트 
        즉, Controller가 받은 요청에 대해 알맞는 정보를 가공해서 다시 Controller에게 데이터를 넘기는 것
        하나의 서비스를 위해 여러개의 DAO를 묶은 트랜잭션이 생성되고, Service는 곧 트랜잭션의 단위가 된다.
        로직을 서비스에 담는 이유는, 비슷한 처리를 서로 다른 페이지에서 요청한다면 각각의 컨트롤러에 중복코드가 발생하지않을까? 그걸 해결하기 위함이다.
#### step1. 일정선택
   * 공연명, 공연표지, 공연일자, 공연장명을 가져와서 **Map<String,Object(list)>** 로 반환한다.
      + 공연명, 공연표지 --> 공연테이블에서 가져온다.
      + 공연일자 --> 회차 테이블에서 가져온다.
      + 공연장명 --> 공연장 테이블에서 가져온다.
   * 공연일자에 따른 회차정보를 가져와야 한다. **List<(String)>** 형태로 회차들을 반환한다.
      + 회차정보 --> 회차 테이블에서 가져온다.
      + 좌석정보 --> 회차-좌석 테이블에서 가져온다.
#### step2. 좌석선택
* 알고있는(파라미터로 받을 수 있는 데이터) : 회차시퀀스, 공연장아이디
* 가져와야 할 데이터 : (죄석행번호 seat_row,좌석열번호 seat_col, 좌석상태 show_seat_status) 리스트
* 회차시퀀스를 가지고 좌석번호, 좌석상태 리스트를 조회한다.
* 회차시퀀스를 가지고 회차좌석가격을 알아야 한다.
* (추가) 잔여석을 구하기 위해 좌석상태가 N인 좌석들의 개수를 카운트 한다.

#### step3. 쿠폰선택
* 유저아이디를 매개변수로 받아 유저-쿠폰 테이블 조회(유저쿠폰아이디, 쿠폰아이디) (쿠폰아이디 구하기 위함)
  + +쿠폰 사용여부가 'N' 인 것들만 조회
  + 조회한 데이터에서 Map<유저쿠폰 아이디,쿠폰아이디> 리스트 추출
* 쿠폰아이디 리스트에서 쿠폰아이디별 쿠폰데이터 조회(쿠폰아이디, 쿠폰명, 쿠폰할인가격, 쿠폰사용조건, 쿠폰사용가능시작일, 종료일)
  + 쿠폰사용가능 시작, 종료일의 포맷을 가공한다.
  + 넘길 데이터의 형식은 List<Map<String(유저쿠폰아이디), List(쿠폰데이터 리스트)>>
- - -
### 4. Controller
        사용자의 요청(request)을 어떻게 처리할지 결정하는 파트 --> parameter가 넘어온다.
#### step1. 일정선택
* 공연 상세페이지에서 예매하기 버튼을 누르면 예매 팝업창을 띄워준다.
   + 공연명, 공연일자, 공연포스터, 공연장명 데이터 필요로 함
* 캘린더의 날짜를 클릭 했을 떼 ajax를 이용하여 회차 데이터를 가져와야 한다.
    + 공연일에 따른 공연회차 데이터 필요로 함
* 회차에 따라 남은 잔여좌석수 정보를 구해야 한다.

* 컨트롤러에서 서비스로 넘겨줄 객체를 만들자... 일정 선택에서 필요한 정보는
     + 공연아이디, 공연일자, 공연회차, 공연 시퀀스? ....--> 더 생각해 봐야 한다.
#### step2. 좌석선택
* ajax를 통해 받아온 회차시퀀스로(구분가능) 좌석번호, 좌석상태 데이터를 조회하여 표시한다.
* 회차테이블에서 회차좌석가격 컬럼을 가져온다. --> ajax(post 요청) : 매개변수 --> 회차시퀀스
* update 쿼리는 이 단에서 사용하지 않는다. >> 결제가 완료되어야 실제 DB에 Update 쿼리가 날라간다.
* 그 전까지는 JS단에서 배열에 담아 관리한다. 

#### step3. 쿠폰선택
* ajax를 통해 유저아이디를 받아와 유저-쿠폰 테이블에서 유저아이디와 동일한 유저-쿠폰 리스트를 구한다.
* 구한 유저-쿠폰 리스트에서 각각 쿠폰아이디를 가지고 쿠폰 테이블에서 쿠폰명, 할인금액, 쿠폰설명, 사용조건을 받아온다.
* 받아온 쿠폰 정보들을 가공하여 List<Map<>> 형태로 반환한다.

- - - 
### 5. View - jsp, js, css
#### step1. 일정선택
* 기본적으로 공연명, 공연일자, 공연표지 정보를 받아와서 표시 해놓아야 한다.
* datepicker를 사용하여 캘린더를 배치한다.
* 캘린더에는 선택된 공연의 공연날짜까 표시되어있어야 한다.
* 캘린더에서 공연 일정을 선택하면 해당 날짜의 회차정보가 공연일에 따라 다르게 보여진다.
* 회차 정보를 선택하면 잔여석 정보가 표시되고 다음단계 버튼이 활성화된다.

#### step2. 좌석선택
* 컨트롤러로부터 좌석번호, 좌석상태, 회차좌석가격 정보를 받아와 표시해야 한다.
* 좌석아이디, 좌석상태를 기준으로 활성화(클릭가능), 비활성화한다.
  + 좌석상태가 'Y'이면 ==> 클릭 비활성화  /  좌석상태가 'N이면' ==> 활성화
* 고객이 좌석을 클릭하면 해당 좌석이 체크되고 해당좌석ID와 가격정보가 우측 패널에 표시된다,
    + 좌석을 클릭하면 JS 단에서 해당 박스의 아이디를 선택한 좌석 리스트에 추가한다.
    + 선택된 좌석 배열을 우측 패널에 표시한다.
* 회차테이블의 회차좌석가격을 가져와서 (리스트의 사이즈 x 회차좌석가격) 출력한다.
* '다음단계' 버튼을 누르면 선택된 선택한 좌석ID List 와 가격정보를 가지고 다음단계로 넘어간다.

#### step3. 쿠폰선택
* 컨트롤러에 유저아이디를 json 데이터로 하는 ajax -post 요청을 보낸다. 
* 컨트롤러로부터 {쿠폰아이디, 쿠폰명, 쿠폰 할인금액, 쿠폰설명, 쿠폰사용조건, 쿠폰사용가능기간}을 응답 데이터로 받아온다.
* 받아온 응답 데이터에서 쿠폰명, 쿠폰할인금액, 쿠폰사용조건, 사용가능기간을 화면에 표시한다. 
* 출력 형식은 게시판의 리스트 형태이다.
* 쿠폰적용 버튼을 누르면 가격 - 할인가격 의 가격이 적용되고 해당 쿠폰 아이디를 저장한다.(결제 완료시 update 쿼리 날리기 위함)
* (참고) 모든 update 쿼리는 결제가 완료되면 이루어진다.
- - - 

### 6. TEST
#### How to Test?
##### _테스트 실행 준비 >> 테스트 진행 >> 테스트 결과 검증_
      - given
        * 테스트를 위해 주어진 상태
        * 테스트 대상에게 주어진 조건
        * 테스트가 동작하기 위해 주어진 환경
      - when
        * 테스트 대상에게 가해진 어떠한 상태
        * 테스트 대상에게 주어진 어떠한 조건
        * 테스트 대상의 상태를 변화시키기 위한 환경
      - then
        * 앞선 과정의 결과
      즉, 어떤 상태에서 출발(given)하여 어떤 상태의 변화를 가했을 때(when) 기대하는 어떠한 상태가 되어야 한다.(then) *
